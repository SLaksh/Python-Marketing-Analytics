# -*- coding: utf-8 -*-
"""CustomerChurn.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YSse-n6q9dcmceBQUeTY5lzI1gYiOEsw

Churn can be Contractual Churn- on expiry of contract, Voluntary churn- cancelling existing service, Involuntary churn - a customer can not pay their credit card bill and no longer stays with the credit card company

The best way to avoid customer churn is to know your customers, and the best way to know your customer is through historical and new customer data.
"""

# Import required libraries
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

df = pd.read_csv("/content/Churn_Modelling.csv")
df.head()

"""Missing values :"""

# Looking for missing data
missing_data=df.isnull()
for column in missing_data.columns.values.tolist():
    print(column)
    print(missing_data[column].value_counts())
    print("")

# Looking at data types
df.dtypes

# looking at the summary
df.describe()

"""The way it works is that we are to split the training data into an observed period and a future period. 

If we want to predict how much a customer will spend in a year, we would set the length of the future period as one year, and the rest would come under observed

![churn.webp](data:image/webp;base64,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)

This helps to build a model on - the amount spent in the OBSERVED PERIOD as features to predict - the amount will be spent in FUTURE
"""

# Looking at Geography and Gender Distribution against Estimated Salary
plt.figure(figsize=(20,20))
sns.catplot(x="Geography", y="EstimatedSalary", hue="Gender", kind="box", data=df)
plt.title("Geography VS Estimated Salary")
plt.xlabel("Geography")
plt.ylabel("Estimated Salary")

"""**Inference:**

-When we look at the relationship between age and credit score, the linear relationship is very weak in order to clearly define correlation.
"""

# Looking at linear relationship between Age and CreditScore
plt.figure(figsize=(10,10))
sns.regplot(x="Age", y="CreditScore", data=df)

"""**When it comes to machine learning models, we are looking for two main conditions; 1- Normal Distribution of the feature set, 2- Same Scale of the feature set.**"""

# Selecting and Preparing the Feature Set and Target
X = df[["CreditScore", "Geography", "Gender", "Age", "Tenure", "EstimatedSalary"]].values
y=df[["Exited"]]
X[0:5], y[0:5]

"""**We have to make sure we update the categorical variables to numerical variables as the machine learning techniques we will apply requires all customers attributes to be numerical.**"""

# preprocessing categorical variables
from sklearn import preprocessing
geography=preprocessing.LabelEncoder()
geography.fit(["France", "Spain", "Germany"])
X[:,1]=geography.transform(X[:,1])

gender = preprocessing.LabelEncoder()
gender.fit(["Female", "Male"])
X[:,2]=gender.transform(X[:,2])

"""**Next split our dataset to training and testing dataset in order to fit our model with training dataset and test the predictions with the testing dataset. The idea is to train the model with the training dataset and test the prediction with the test dataset.**"""

# split train and test data
from sklearn.model_selection import train_test_split
X_trainset, X_testset, y_trainset, y_testset = train_test_split(X, y, test_size=0.2, random_state=3)

"""# **DecisionTreeClassifier and RandomForestClassifier to create our model**"""

# create model using DecisionTree Classifier and fit training data
from sklearn.tree import DecisionTreeClassifier
dt_model = DecisionTreeClassifier()
dt_model.fit(X_trainset, y_trainset)

# create prediction
dt_pred = dt_model.predict(X_testset)
dt_pred[0:5]

# Evaluating the prediction model
from sklearn import metrics
metrics.accuracy_score(y_testset, dt_pred)

# create Random Forest Decision Tree model
from sklearn.ensemble import RandomForestClassifier
rf_model = RandomForestClassifier(n_estimators=100)
rf_model.fit(X_trainset, y_trainset.values.ravel())

# create prediction using rf_model
rf_pred = rf_model.predict(X_testset)
rf_pred[0:5]

# evaluate the model
metrics.accuracy_score(y_testset, rf_pred)

"""# **Inference:**

**73% of the predictions would be accurate with the Decision Classifier Model, 82% of the predictions would be accurate with the RandomForestClassifier. **

# Another Dataset
"""

import pandas as pd

df = pd.read_csv("/content/churn-bigml-80.csv")
df.head()

# for loop to see unique values
for column in df.columns.values.tolist():
    print(column)
    print(df[column].unique())
    print("")

df.info

# feature selection
X = df[["Account length", "International plan", "Total day charge", "Total night charge", "Total intl charge", "Customer service calls", "State"]]
# target selection
y =df["Churn"]
# review feature set
X[0:5]

"""**Preprocessing and update the categorical variables to numeric variables in order to create Model**"""

from pandas import Series

from pandas._libs import internals
# update state with one hot coding
X = pd.get_dummies(df, columns =["State"])

df.dtypes

df.columns

# Churners vs Non-Churners
df['Churn'].value_counts()

"""**To group data by Churn and compute the mean to find out if churners make more customer service calls than non-churners**"""

# Group data by 'Churn' and compute the mean
print(df.groupby('Churn')['Customer service calls'].mean())

"""# **Inference**

Perhaps unsurprisingly, churners seem to make more customer service calls than non-churners.

**To find out if one State has more churners compared to another.**
"""

# Count the number of churners and non-churners by State
print(df.groupby('State')['Churn'].value_counts())

pd.options.display.max_colwidth

print(df.groupby('State')['Churn'].value_counts())

"""# ***Exploring Data Visualizations ***
To understand how variables are distributed.
"""

# Import matplotlib and seaborn
import matplotlib.pyplot as plt
import seaborn as sns

# Visualize the distribution of 'Total day minutes'
plt.hist(df['Total day minutes'], bins = 100)

# Display the plot
plt.show()

"""**To visualize the difference in Customer service calls between churners and non-churners**"""

# Create the box plot
sns.boxplot(x = 'Churn',
			y = 'Customer service calls',
			data = df,
			sym = "",				
			hue = "International plan")
# Display the plot
plt.show()

"""Some pre-processing technique to consider


1.   The features are normally distributed
2.   The features are on the same scale
3.   The datatypes of features are numeric

In this dataset Churn, Voice mail plan, and, International plan, in particular, are binary features that can easily be converted into 0’s and 1’s
"""

# Features and Labels
X = df.iloc[:, 0:19].values
y = df.iloc[:, 19].values # Churn
  
# Encoding categorical data in X
from sklearn.preprocessing import LabelEncoder
  
labelencoder_X_1 = LabelEncoder()
X[:, 3] = labelencoder_X_1.fit_transform(X[:, 3])
  
labelencoder_X_2 = LabelEncoder()
X[:, 4] = labelencoder_X_2.fit_transform(X[:, 4])
  
# Encoding categorical data in y
labelencoder_y = LabelEncoder()
y = labelencoder_y.fit_transform(y)

"""Encoding State feature using One hot encoding

**One-hot encoding** converts the categorical data into numeric data by splitting the column into multiple columns. The numbers are replaced by 1s and 0s, depending on which column has what value.

**Label encoding** is very simple and it involves converting each value in a column into a number.

https://towardsdatascience.com/choosing-the-right-encoding-method-label-vs-onehot-encoder-a4434493149b

**Encoding State feature using One hot encoding**
"""

# Removing extra column to avoid dummy variable trap
X_State = pd.get_dummies(X[:, 0], drop_first = True)

# Converting X to a dataframe
X = pd.DataFrame(X)

# Dropping the 'State' column
X = X.drop([0], axis = 1)

# Merging two dataframes
frames = [X_State, X]
result = pd.concat(frames, axis = 1, ignore_index = True)

# Final dataset with all numeric features
X = result

"""**To Create Training and Test sets**"""

# Splitting the dataset into the Training and Test sets
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y,
													test_size = 0.2,
													random_state = 0)

"""**To scale features of the training and test sets**"""

# Feature Scaling
from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)

"""**To train a Random Forest classifier model on the training set.**"""

# Import RandomForestClassifier
from sklearn.ensemble import RandomForestClassifier

# Instantiate the classifier
clf = RandomForestClassifier()

# Fit to the training data
clf.fit(X_train, y_train)

"""**Making Predictions**"""

# Predict the labels for the test set
y_pred = clf.predict(X_test)

"""**Code: Evaluating Model Performance**"""

# Compute accuracy
from sklearn.metrics import accuracy_score

accuracy_score(y_test, y_pred)

"""**Confusion Matrix**"""

from sklearn.metrics import confusion_matrix
print(confusion_matrix(y_test, y_pred))

"""From the confusion matrix, we can compute the following metrics:

True Positives(TP) = 37
True Negatives(TN) = 465
False Positives(FP) = 0
False Negatives(FN) = 32
Precision = TP/(TP+FP) = 1
Recall = TP/(TP+FN) = 0.53
Accuracy = (TP+TN)/(TP+TN+FP+FN) = 0.940
"""