# -*- coding: utf-8 -*-
"""Conjoint.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1K0Hr5au72cZiH0nbiRSMQSgsFcLejkVS
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()
import datetime as dt
import warnings
warnings.filterwarnings('ignore')

df =  pd.read_csv("/content/pizza_data.csv")
df.shape

df.info()

"""**To tell the model that a variable is categorical, it needs to be wrapped in C(independent_variable)**

**Patsy is a Python library that allows data transformation using arbitrary Python code. With Patsy, you could use human-readable syntax such as life_expectancy ~ income_group + year + region (life expectancy depends on income group, year, and region)**
"""

import statsmodels.api as sm
import statsmodels.formula.api as smf

model='ranking ~ C(brand,Sum)+C(price,Sum)+C(weight,Sum)+C(crust,Sum)+C(cheese,Sum)+C(size,Sum)+C(toppings,Sum)+C(spicy,Sum)'
model_fit=smf.ols(model,data=df).fit()
print(model_fit.summary())

"""** The Ordinary Least Squares (OLS) regression technique falls under the Supervised Learning. It is a method for estimating the unknown parameters by creating a model which will minimize the sum of the squared errors between the observed data and the predicted one.**"""

conjoint_attributes = ['brand','price','weight','crust','cheese','size','toppings','spicy']

"""**Before going ahead, we need to understand these conjoint analysis terminologies:**

**Relative importance**: It depicts which attributes are more or less important when purchasing. E.g., a Mobile Phone’s Relative importance could be Brand 30%, Price 30%, Size 20%, Battery Life 10%, and Color 10%.

**Part-Worths/Utility values**: The amount of weight an attribute level carries with a respondent. These factors lead to a product’s overall value to consumers.

Now we will build part-worths information and calculate attribute-wise importance level.
"""

level_name = []
part_worth = []
part_worth_range = []
important_levels = {}
end = 1  # Initialize index for coefficient in params

for item in conjoint_attributes:
    nlevels = len(list(np.unique(df[item])))
    level_name.append(list(np.unique(df[item])))
    
    begin = end
    end = begin + nlevels -1
    
    new_part_worth = list(model_fit.params[begin:end])
    new_part_worth.append((-1)*sum(new_part_worth))
    important_levels[item] = np.argmax(new_part_worth)
    part_worth.append(new_part_worth)
    print(item)
    #print(part_worth)
    part_worth_range.append(max(new_part_worth) - min(new_part_worth))
    # next iteration
print("-------------------------------------------------------------")
print("level name:")
print(level_name)
print("npw with sum element:")
print(new_part_worth)
print("imp level:")
print(important_levels)
print("part worth:")
print(part_worth)
print("part_worth_range:")
print(part_worth_range)
print(len(part_worth))
print("important levels:")
print(important_levels)

"""**NOW WE WILL CALCULATE THE IMPORTANCE OF EACH ATTRIBUTE.**"""

attribute_importance = []
for i in part_worth_range:
    #print(i)
    attribute_importance.append(round(100*(i/sum(part_worth_range)),2))
print(attribute_importance)

"""**NOW WE WILL CALCULATE THE PART-WORTH OF EACH ATTRIBUTE LEVEL.**"""

part_worth_dict={}
attrib_level={}
for item,i in zip(conjoint_attributes,range(0,len(conjoint_attributes))):
    print("Attribute :",item)
    print("    Relative importance of attribute ",attribute_importance[i])
    print("    Level wise part worths: ")
    for j in range(0,len(level_name[i])):
        print(i)
        print(j)
        print("          {}:{}".format(level_name[i][j],part_worth[i][j]))
        part_worth_dict[level_name[i][j]]=part_worth[i][j]
        attrib_level[item]=(level_name[i])
        #print(j)
part_worth_dict

"""**NOW WE WILL PLOT THE RELATIVE IMPORTANCE OF ATTRIBUTES**"""

plt.figure(figsize=(10,5))
sns.barplot(x=conjoint_attributes,y=attribute_importance)
plt.title('Relative importance of attributes')
plt.xlabel('Attributes')
plt.ylabel('Importance')

"""**NOW WE WILL CALCULATE THE UTILITY SCORE OF EACH PROFILE**"""

utility = []
for i in range(df.shape[0]):
    score = part_worth_dict[df['brand'][i]]+ part_worth_dict[df['price'][i]]+ part_worth_dict[df['weight'][i]]+ part_worth_dict[df['crust'][i]]+ part_worth_dict[df['cheese'][i]]+ part_worth_dict[df['size'][i]]+ part_worth_dict[df['toppings'][i]]+ part_worth_dict[df['spicy'][i]]
    utility.append(score)
    
df['utility'] = utility
utility

plt.figure(figsize=(10,5))
sns.barplot(x=conjoint_attributes,y=utility)
plt.title('Relative importance of attributes')
plt.xlabel('Attributes')
plt.ylabel('Utility')

"""**NOW WE WILL FIND THE COMBINATION WITH MAXIMUM UTILITY**"""

print("The profile that has the highest utility score :",'\n', df.iloc[np.argmax(utility)])

"""**NOW WE WILL DETERMINE THE LEVELS BEING PREFERRED IN EACH ATTRIBUTE**"""

for i,j in zip(attrib_level.keys(),range(0,len(conjoint_attributes))):
    #print(i)
    #level_name[j]
    print("Preferred level in {} is :: {}".format(i,level_name[j][important_levels[i]]))